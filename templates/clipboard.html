{% extends "base.html" %}

{% block title %}{{ _('Shared Clipboard') }} - {{ _('Social Connect') }}{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1><i class="fas fa-clipboard"></i> {{ _('Shared Clipboard with %(username)s', username=other_user.username) }}</h1>
        <div>
            <span id="partner-status" class="partner-status"></span>
            <a href="{{ url_for('dashboard') }}" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> {{ _('Back') }}</a>
        </div>
    </div>
    
    <div class="clipboard-container">
        <div class="clipboard-pane other-pane">
            <h3><i class="fas fa-user-friends"></i> {{ _("%(username)s's Area", username=other_user.username) }}</h3>
            <div id="other-display" class="clipboard-display">
                <textarea id="other-clipboard" class="clipboard-textarea" 
                          placeholder="{{ _('Waiting for %(username)s to type...', username=other_user.username) }}" readonly></textarea>
                <div class="clipboard-drawing-wrap">
                    <canvas id="other-drawing-canvas" width="600" height="360"></canvas>
                </div>
            </div>
        </div>
        <div class="clipboard-pane user-pane">
            <h3><i class="fas fa-user"></i> {{ _('Your Area (%(username)s)', username=current_user.username) }}</h3>
            <div id="my-display" class="clipboard-display">
                <textarea id="my-clipboard" class="clipboard-textarea" 
                          placeholder="{{ _('Type here... Changes sync in real-time') }}"></textarea>
                <div class="clipboard-drawing-wrap">
                    <canvas id="my-drawing-canvas" width="600" height="360"></canvas>
                </div>
            </div>
            <div class="clipboard-toolbar">
                <div class="toolbar-group">
                    <button type="button" class="toolbar-btn active" data-mode="text">
                        <i class="fas fa-font"></i> {{ _('Text') }}
                    </button>
                    <button type="button" class="toolbar-btn" data-mode="drawing">
                        <i class="fas fa-pen-nib"></i> {{ _('Handwriting') }}
                    </button>
                </div>
                <div class="toolbar-group">
                    <div class="toolbar-select">
                        <button type="button" class="toolbar-btn" id="mood-toggle">
                            <i class="far fa-face-smile"></i> {{ _('Mood') }}
                        </button>
                        <div class="toolbar-dropdown" id="mood-menu">
                            <button type="button" class="dropdown-item" data-prefix="[üòÅ{{ _('Happy') }}] ">
                                üòÅ {{ _('Happy') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòû{{ _('Pout') }}] ">
                                üòû {{ _('Pout') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòä{{ _('Warm') }}] ">
                                üòä {{ _('Warm') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòî{{ _('Sad') }}] ">
                                üòî {{ _('Sad') }}
                            </button>
                        </div>
                    </div>
                    <div class="toolbar-select">
                        <button type="button" class="toolbar-btn" id="sticker-toggle">
                            <i class="fas fa-icons"></i> {{ _('Stickers') }}
                        </button>
                        <div class="toolbar-dropdown" id="sticker-menu">
                            <button type="button" class="dropdown-item" data-emoji="üéâ">üéâ {{ _('Celebrate') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="‚ú®">‚ú® {{ _('Sparkle') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="üî•">üî• {{ _('Fire') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="üí°">üí° {{ _('Idea') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="fa-solid fa-heart">‚ù§ {{ _('Heart') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="fa-solid fa-star">‚≠ê {{ _('Star') }}</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="clipboard-sticker-layer" id="clipboard-sticker-layer"></div>
</div>

<script>
// Diagnostic: Check if socket.io is available
if (typeof io === 'undefined') {
    document.body.insertAdjacentHTML('beforeend', '<div style="position: fixed; bottom: 0; left: 0; right: 0; background: #DC2626; color: white; padding: 10px; text-align: center; z-index: 99999; font-weight: bold;">‚ùå Socket.ioÊú™Âä†ËΩΩ | Socket.io not loaded</div>');
}

let socket = io();
const connectionId = {{ connection.id }};
const myUserId = {{ current_user.id }};
const otherUserId = {{ other_user.id }};
const otherUsername = {{ other_user.username | tojson }};
let roomJoined = false;
let isSocketConnected = false;
let activeMode = 'text';
let moodPrefix = '';
let drawingPlaybackTimer = null;
let drawingPoints = [];
let otherDrawingHistory = [];
let lastRemoteTimestamp = null;
let lastMoodPrefix = '';
let drawingIsComposing = false;
let otherDrawingHasContent = false;
let localDrawingHasContent = false;
let remoteDrawingActive = false;
let isReplaying = false;
let otherLastStroke = 0;

// Show initial connecting status
if (typeof updateSocketStatus === 'function') {
    updateSocketStatus('connecting', '{{ _('Connecting...') }}');
} else {
    // Fallback if function not defined
    const simpleStatus = document.getElementById('simple-socket-status');
    if (simpleStatus) {
        simpleStatus.style.display = 'inline-block';
        simpleStatus.textContent = '‚è≥ {{ _('Connecting...') }}';
    }
}

// Socket connection event handlers
socket.on('connect', function() {
    isSocketConnected = true;
    updateSocketStatus('connected', '{{ _('Connected') }}');
    
    // Track page for online status
    socket.emit('set_page', { page: 'clipboard', connection_id: connectionId });
    
    // Join clipboard room with acknowledgment
    socket.emit('join_clipboard', { connection_id: connectionId }, function(ack) {
        if (ack) {
            roomJoined = true;
        } else {
            showNotification('{{ _('Failed to join clipboard. Please refresh the page.') }}', 'error');
        }
    });
    
    // Get partner status after joining room
    socket.emit('get_user_status', { connection_id: connectionId }, function(status) {
        updatePartnerStatus(status);
    });
});

socket.on('connect_error', function(error) {
    isSocketConnected = false;
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    handleSocketError(error, 'clipboard connect');
});

socket.on('disconnect', function(reason) {
    isSocketConnected = false;
    roomJoined = false;
    updateSocketStatus('disconnected', '{{ _('Disconnected') }}');
    showNotification('{{ _('Connection lost. Changes may not sync until reconnected.') }}', 'warning', 3000);
});

socket.on('reconnect', function(attemptNumber) {
    updateSocketStatus('connected', '{{ _('Reconnected') }}');
    showNotification('{{ _('Reconnected successfully!') }}', 'success', 2000);
});

socket.on('reconnect_attempt', function(attemptNumber) {
    updateSocketStatus('connecting', '{{ _('Reconnecting...') }} (' + attemptNumber + ')');
});

socket.on('reconnect_error', function(error) {
    handleSocketError(error, 'clipboard reconnect');
});

socket.on('reconnect_failed', function() {
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    showNotification('{{ _('Unable to reconnect. Please refresh the page.') }}', 'error', 0);
});

// Track page for online status (initial)
// Moved to connect event handler to ensure socket is connected

// Get partner status (will be called after connection is established)

function updatePartnerStatus(status) {
    const statusEl = document.getElementById('partner-status');
    if (status.online) {
        if (status.page === 'clipboard') {
            statusEl.innerHTML = '<span class="status-online"><i class="fas fa-circle"></i> {{ _('Online') }}</span>';
        } else {
            statusEl.innerHTML = '<span class="status-away"><i class="fas fa-circle"></i> {{ _('Away') }}</span>';
        }
    } else {
        statusEl.innerHTML = '<span class="status-offline"><i class="far fa-circle"></i> {{ _('Offline') }}</span>';
    }
}

socket.on('user_status_changed', function(data) {
    if (data.user_id === otherUserId) {
        updatePartnerStatus({ online: data.online, page: data.page });
    }
});

const myClipboard = document.getElementById('my-clipboard');
const otherClipboard = document.getElementById('other-clipboard');
const myDisplay = document.getElementById('my-display');
const otherDisplay = document.getElementById('other-display');
const myDrawingCanvas = document.getElementById('my-drawing-canvas');
const otherDrawingCanvas = document.getElementById('other-drawing-canvas');
const myDrawingCtx = myDrawingCanvas.getContext('2d');
const otherDrawingCtx = otherDrawingCanvas.getContext('2d');
const stickerLayer = document.getElementById('clipboard-sticker-layer');
const toolbarButtons = document.querySelectorAll('.toolbar-btn[data-mode]');
const moodToggle = document.getElementById('mood-toggle');
const moodMenu = document.getElementById('mood-menu');
const stickerToggle = document.getElementById('sticker-toggle');
const stickerMenu = document.getElementById('sticker-menu');

function setActiveMode(mode) {
    activeMode = mode;
    toolbarButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    const isDrawing = mode === 'drawing';
    myDisplay.classList.toggle('drawing-active', isDrawing);
    otherDisplay.classList.toggle('drawing-active', isDrawing || remoteDrawingActive);
    document.querySelector('.clipboard-container').classList.toggle('handwriting-mode', isDrawing);
    if (isDrawing) {
        scheduleCanvasResize();
    }
    if (!isDrawing) {
        stopDrawingPlayback();
        if (localDrawingHasContent) {
            clearMyDrawing();
        }
    } else if (!drawingPoints.length && otherDrawingHistory.length) {
        scheduleCanvasResize();
        setTimeout(replayDrawingHistory, 0);
    } else if (isDrawing) {
        scheduleCanvasResize();
    }
}

function setRemoteDrawingActive(active) {
    remoteDrawingActive = active;
    otherDisplay.classList.toggle('drawing-active', active || activeMode === 'drawing');
    if (remoteDrawingActive) {
        scheduleCanvasResize();
    }
}

function toggleDropdown(button, menu) {
    const isOpen = menu.classList.toggle('open');
    button.classList.toggle('active', isOpen);
}

document.addEventListener('click', (event) => {
    if (!moodToggle.contains(event.target) && !moodMenu.contains(event.target)) {
        moodMenu.classList.remove('open');
        moodToggle.classList.remove('active');
    }
    if (!stickerToggle.contains(event.target) && !stickerMenu.contains(event.target)) {
        stickerMenu.classList.remove('open');
        stickerToggle.classList.remove('active');
    }
});

toolbarButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        setActiveMode(btn.dataset.mode);
    });
});

moodToggle.addEventListener('click', () => {
    toggleDropdown(moodToggle, moodMenu);
});

stickerToggle.addEventListener('click', () => {
    toggleDropdown(stickerToggle, stickerMenu);
});

moodMenu.querySelectorAll('.dropdown-item').forEach(item => {
    item.addEventListener('click', () => {
        moodPrefix = item.dataset.prefix || '';
        applyMoodPrefix();
        myClipboard.focus();
        moodMenu.classList.remove('open');
        moodToggle.classList.remove('active');
    });
});

stickerMenu.querySelectorAll('.dropdown-item').forEach(item => {
    item.addEventListener('click', () => {
        const emoji = item.dataset.emoji;
        spawnSticker(emoji);
        broadcastSticker(emoji);
        stickerMenu.classList.remove('open');
        stickerToggle.classList.remove('active');
    });
});

function spawnSticker(emoji) {
    if (!emoji) return;
    const sticker = document.createElement('div');
    sticker.className = 'sticker-burst';
    if (emoji.startsWith('fa-')) {
        sticker.innerHTML = `<i class="${emoji}"></i>`;
    } else {
        sticker.textContent = emoji;
    }
    const rect = stickerLayer.getBoundingClientRect();
    const startX = Math.random() * rect.width * 0.6 + rect.width * 0.2;
    sticker.style.setProperty('--sticker-start-x', `${startX}px`);
    const shift = (Math.random() * 120) - 60;
    sticker.style.setProperty('--sticker-shift', `${shift}px`);
    stickerLayer.appendChild(sticker);
    sticker.addEventListener('animationend', () => sticker.remove());
}

function broadcastSticker(emoji) {
    if (!roomJoined || !isSocketConnected) {
        return;
    }
    socket.emit('clipboard_sticker', {
        connection_id: connectionId,
        emoji
    });
}

function prependMoodPrefix(prefix, shouldSend) {
    if (!prefix) return;
    const newValue = myClipboard.value.replace(/^\[[^\]]+\]\s*/, '');
    myClipboard.value = prefix + newValue;
    lastLocalClipboard = myClipboard.value;
    lastMoodPrefix = prefix;
    if (shouldSend) {
        sendClipboardUpdate(myClipboard.value);
    }
}

function applyMoodPrefix() {
    const prefix = moodPrefix;
    moodPrefix = '';
    prependMoodPrefix(prefix, true);
}

function clearCanvas(ctx, canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

let canvasResizePending = false;

function getCanvasSize(canvas) {
    const container = canvas.parentElement;
    let width = container.offsetWidth || container.clientWidth;
    let height = container.offsetHeight || container.clientHeight;
    if (width < 1 || height < 1) {
        const display = canvas.closest('.clipboard-display');
        if (display) {
            width = display.clientWidth || width;
            height = display.clientHeight || height;
        }
    }
    width = Math.round(width) || canvas.width || 600;
    height = Math.round(height) || canvas.height || 360;
    return { width, height };
}

function setupDrawingCanvas(canvas, ctx) {
    const size = getCanvasSize(canvas);
    if (size.width < 1 || size.height < 1) {
        return false;
    }
    const resized = canvas.width !== size.width || canvas.height !== size.height;
    canvas.width = size.width;
    canvas.height = size.height;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    if (resized) {
        clearCanvas(ctx, canvas);
    }
    return true;
}

function refreshDrawingCanvases() {
    const myReady = setupDrawingCanvas(myDrawingCanvas, myDrawingCtx);
    const otherReady = setupDrawingCanvas(otherDrawingCanvas, otherDrawingCtx);
    if (!myReady || !otherReady) {
        scheduleCanvasResize();
    }
}

function scheduleCanvasResize() {
    if (canvasResizePending) return;
    canvasResizePending = true;
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            canvasResizePending = false;
            refreshDrawingCanvases();
        });
    });
}

refreshDrawingCanvases();
window.addEventListener('resize', () => {
    if (activeMode === 'drawing' || remoteDrawingActive) {
        scheduleCanvasResize();
    }
});

let isDrawing = false;
let lastX = 0;
let lastY = 0;

function startDraw(e) {
    if (activeMode !== 'drawing') return;
    const rect = myDrawingCanvas.getBoundingClientRect();
    isDrawing = true;
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    emitDrawing({ type: 'stroke_start', x: lastX, y: lastY });
}

function drawStroke(x, y) {
    myDrawingCtx.lineWidth = 4;
    myDrawingCtx.strokeStyle = '#1f2937';
    myDrawingCtx.lineTo(x, y);
    myDrawingCtx.stroke();
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(x, y);
    localDrawingHasContent = true;
    lastX = x;
    lastY = y;
    emitDrawing({ type: 'draw', x, y });
}

function moveDraw(e) {
    if (!isDrawing || activeMode !== 'drawing') return;
    const rect = myDrawingCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    drawStroke(x, y);
    lastX = x;
    lastY = y;
}

function endDraw() {
    if (!isDrawing) return;
    isDrawing = false;
    myDrawingCtx.beginPath();
    emitDrawing({ type: 'stroke_end' });
    lastX = 0;
    lastY = 0;
}

function emitDrawing(drawing) {
    if (!roomJoined || !isSocketConnected) return;
    if (!drawing.ts) {
        drawing.ts = Date.now() / 1000;
    }
    socket.emit('clipboard_drawing', {
        connection_id: connectionId,
        drawing
    });
}

function clearMyDrawing() {
    clearCanvas(myDrawingCtx, myDrawingCanvas);
    emitDrawing({ type: 'clear' });
    localDrawingHasContent = false;
    setRemoteDrawingActive(false);
}

myDrawingCanvas.addEventListener('mousedown', startDraw);
myDrawingCanvas.addEventListener('mousemove', moveDraw);
myDrawingCanvas.addEventListener('mouseup', endDraw);
myDrawingCanvas.addEventListener('mouseout', endDraw);

myDrawingCanvas.addEventListener('touchstart', (event) => {
    event.preventDefault();
    if (activeMode !== 'drawing') return;
    const touch = event.touches[0];
    const rect = myDrawingCanvas.getBoundingClientRect();
    isDrawing = true;
    lastX = touch.clientX - rect.left;
    lastY = touch.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    emitDrawing({ type: 'stroke_start', x: lastX, y: lastY });
}, { passive: false });

myDrawingCanvas.addEventListener('touchmove', (event) => {
    event.preventDefault();
    if (!isDrawing || activeMode !== 'drawing') return;
    const touch = event.touches[0];
    const rect = myDrawingCanvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    drawStroke(x, y);
}, { passive: false });

myDrawingCanvas.addEventListener('touchend', (event) => {
    event.preventDefault();
    endDraw();
}, { passive: false });

function queueDrawingPoint(drawing) {
    if (drawing.type === 'clear') {
        otherDrawingHistory = [];
        drawingPoints = [];
        otherDrawingHasContent = false;
        clearCanvas(otherDrawingCtx, otherDrawingCanvas);
        setRemoteDrawingActive(false);
        return;
    } else {
        otherDrawingHistory.push(drawing);
        otherDrawingHasContent = true;
        drawingPoints.push(drawing);
    }
    otherLastStroke = Date.now();
    if (drawing.type === 'stroke_start' || drawing.type === 'draw') {
        setRemoteDrawingActive(true);
    }
    lastRemoteTimestamp = drawing.ts || lastRemoteTimestamp;
}

function stopDrawingPlayback() {
    if (drawingPlaybackTimer) {
        clearInterval(drawingPlaybackTimer);
        drawingPlaybackTimer = null;
    }
    isReplaying = false;
}

function startDrawingPlayback() {
    if (drawingPlaybackTimer) return;
    isReplaying = true;
    const drawing = drawingPoints.shift();
    if (!drawing) {
        stopDrawingPlayback();
        return;
    }
    renderDrawing(otherDrawingCtx, otherDrawingCanvas, drawing);
    const next = drawingPoints[0];
    const delay = Math.min(200, Math.max(12, computeDrawingDelay(drawing, next)));
    startDrawingPlaybackWithDelay(delay);
}

function startDrawingPlaybackWithDelay(delay) {
    if (drawingPlaybackTimer) return;
    isReplaying = true;
    drawingPlaybackTimer = setTimeout(() => {
        drawingPlaybackTimer = null;
        if (drawingPoints.length === 0) {
            stopDrawingPlayback();
            return;
        }
        const drawing = drawingPoints.shift();
        renderDrawing(otherDrawingCtx, otherDrawingCanvas, drawing);
        const next = drawingPoints[0];
        const nextDelay = Math.min(200, Math.max(12, computeDrawingDelay(drawing, next)));
        startDrawingPlaybackWithDelay(nextDelay);
    }, delay);
}

function computeDrawingDelay(current, next) {
    if (!current || !next) {
        return 40;
    }
    if (!current.ts || !next.ts) {
        return 40;
    }
    return (next.ts - current.ts) * 1000;
}

function renderDrawing(ctx, canvas, drawing) {
    if (!drawing) return;
    if (drawing.type === 'clear') {
        clearCanvas(ctx, canvas);
        if (ctx === otherDrawingCtx) {
            otherDrawingHistory = [];
            otherDrawingHasContent = false;
        }
        return;
    }
    if (drawing.type === 'stroke_start') {
        ctx.beginPath();
        ctx.moveTo(drawing.x, drawing.y);
        return;
    }
    if (drawing.type === 'stroke_end') {
        return;
    }
    // For 'draw' type - continue the current path
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#1f2937';
    ctx.lineTo(drawing.x, drawing.y);
    ctx.stroke();
    if (ctx === otherDrawingCtx) {
        otherDrawingHasContent = true;
    }
}

function replayDrawingHistory() {
    if (!otherDrawingHistory.length) {
        return;
    }
    drawingPoints = otherDrawingHistory.slice();
    clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    startDrawingPlayback();
}

// Load existing content
{% if clipboard_data %}
    {% if current_user.id in clipboard_data %}
    document.getElementById('my-clipboard').value = {{ clipboard_data[current_user.id].content|tojson }};
    {% endif %}
    {% if other_user.id in clipboard_data %}
    document.getElementById('other-clipboard').value = {{ clipboard_data[other_user.id].content|tojson }};
    {% endif %}
{% endif %}
let lastLocalClipboard = myClipboard.value;

function shouldUpdateLocalClipboard(content) {
    return document.activeElement !== myClipboard && content !== lastLocalClipboard;
}

// Send updates with shorter delay for faster sync
let timeout;
let isComposing = false; // Track IME composition state

function sendClipboardUpdate(content) {
    if (!isSocketConnected) {
        showNotification('{{ _('Not connected. Changes will sync when connection is restored.') }}', 'warning', 3000);
        return;
    }
    if (roomJoined) {
        socket.emit('clipboard_update', {
            connection_id: connectionId,
            content: content
        });
    }
}

myClipboard.addEventListener('compositionstart', function(e) {
    isComposing = true;
    drawingIsComposing = true;
});

myClipboard.addEventListener('input', function(e) {
    // Skip input event during IME composition to avoid conflicts
    if (isComposing) {
        return;
    }
    
    clearTimeout(timeout);
    if (!drawingIsComposing) {
        const prefixMatch = e.target.value.match(/^\[[^\]]+\]\s*/);
        if (prefixMatch) {
            lastMoodPrefix = prefixMatch[0];
        }
        if (moodPrefix) {
            const prefix = moodPrefix;
            const hasPrefix = e.target.value.startsWith(prefix);
            moodPrefix = '';
            prependMoodPrefix(prefix, false);
            if (!hasPrefix) {
                const selectionStart = e.target.selectionStart;
                const selectionEnd = e.target.selectionEnd;
                const offset = prefix.length;
                e.target.setSelectionRange(selectionStart + offset, selectionEnd + offset);
            }
        }
    }
    setRemoteDrawingActive(false);
    clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    lastLocalClipboard = e.target.value;
    timeout = setTimeout(() => {
        sendClipboardUpdate(e.target.value);
    }, 200); // Reduced from 500ms to 200ms for faster sync
});
 
// Add support for composition events (pinyin/IME input)
myClipboard.addEventListener('compositionupdate', function(e) {
    // Sync even during composition (pinyin typing)
    clearTimeout(timeout);
    lastLocalClipboard = e.target.value;
    timeout = setTimeout(() => {
        sendClipboardUpdate(myClipboard.value); // Use current value to avoid race conditions
    }, 150); // Even faster for composition to show real-time pinyin
});

myClipboard.addEventListener('compositionend', function(e) {
    isComposing = false;
    drawingIsComposing = false;
    // Final sync when composition completes
    clearTimeout(timeout);
    lastLocalClipboard = e.target.value;
    sendClipboardUpdate(e.target.value);
});

myClipboard.addEventListener('focus', () => {
    setActiveMode('text');
});

// Receive updates
socket.on('clipboard_sync', function(data) {
    if (data.user_id === myUserId) {
        if (shouldUpdateLocalClipboard(data.content)) {
            myClipboard.value = data.content;
        }
        return;
    }
    if (data.content !== otherClipboard.value) {
        otherClipboard.value = data.content;
    }
    if (data.content.trim()) {
        setRemoteDrawingActive(false);
        clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    }
});

socket.on('clipboard_drawing_update', function(data) {
    if (data.user_id === myUserId) {
        renderDrawing(myDrawingCtx, myDrawingCanvas, data.drawing);
        if (data.drawing.type === 'clear') {
            clearCanvas(myDrawingCtx, myDrawingCanvas);
        }
        return;
    }
    scheduleCanvasResize();
    queueDrawingPoint(data.drawing);
    startDrawingPlayback();
});

socket.on('clipboard_sticker_show', function(data) {
    if (data.user_id === myUserId) {
        return;
    }
    spawnSticker(data.emoji);
});

setActiveMode('text');
setInterval(() => {
    if (!remoteDrawingActive) {
        return;
    }
    const idleTooLong = Date.now() - otherLastStroke > 2000;
    const hasHistory = otherDrawingHistory.length > 0;
    const noPending = drawingPoints.length === 0;
    if (noPending && hasHistory && otherDrawingHasContent && !isReplaying && idleTooLong) {
        replayDrawingHistory();
    }
    if (Date.now() - otherLastStroke > 5000) {
        setRemoteDrawingActive(false);
    }
}, 2000);
</script>
{% endblock %}
