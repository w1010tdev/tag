{% extends "base.html" %}

{% block title %}{{ _('Shared Clipboard') }} - {{ _('Social Connect') }}{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1><i class="fas fa-clipboard"></i> {{ _('Shared Clipboard with %(username)s', username=other_user.username) }}</h1>
        <div>
            <span id="partner-status" class="partner-status"></span>
            <a href="{{ url_for('dashboard') }}" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> {{ _('Back') }}</a>
        </div>
    </div>
    
    <div class="clipboard-container">
        <div class="clipboard-pane other-pane">
            <h3><i class="fas fa-user-friends"></i> {{ _("%(username)s's Area", username=other_user.username) }}</h3>
            <div id="other-display" class="clipboard-display">
                <textarea id="other-clipboard" class="clipboard-textarea" 
                          placeholder="{{ _('Waiting for %(username)s to type...', username=other_user.username) }}" readonly></textarea>
                <div class="clipboard-drawing-wrap">
                    <canvas id="other-drawing-canvas" width="600" height="360"></canvas>
                </div>
            </div>
        </div>
        <div class="clipboard-pane user-pane">
            <h3><i class="fas fa-user"></i> {{ _('Your Area (%(username)s)', username=current_user.username) }}</h3>
            <div id="my-display" class="clipboard-display">
                <textarea id="my-clipboard" class="clipboard-textarea" 
                          placeholder="{{ _('Type here... Changes sync in real-time') }}"></textarea>
                <div class="clipboard-drawing-wrap">
                    <canvas id="my-drawing-canvas" width="600" height="360"></canvas>
                </div>
            </div>
            <div class="clipboard-toolbar">
                <div class="toolbar-group">
                    <button type="button" class="toolbar-btn active" data-mode="text">
                        <i class="fas fa-font"></i> {{ _('Text') }}
                    </button>
                    <button type="button" class="toolbar-btn" data-mode="drawing">
                        <i class="fas fa-pen-nib"></i> {{ _('Handwriting') }}
                    </button>
                </div>
                <div class="toolbar-group">
                    <div class="toolbar-select">
                        <button type="button" class="toolbar-btn" id="mood-toggle">
                            <i class="far fa-face-smile"></i> {{ _('Mood') }}
                        </button>
                        <div class="toolbar-dropdown" id="mood-menu">
                            <button type="button" class="dropdown-item" data-prefix="[üòÅ{{ _('Happy') }}] ">
                                üòÅ {{ _('Happy') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòû{{ _('Pout') }}] ">
                                üòû {{ _('Pout') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòä{{ _('Warm') }}] ">
                                üòä {{ _('Warm') }}
                            </button>
                            <button type="button" class="dropdown-item" data-prefix="[üòî{{ _('Sad') }}] ">
                                üòî {{ _('Sad') }}
                            </button>
                        </div>
                    </div>
                    <div class="toolbar-select">
                        <button type="button" class="toolbar-btn" id="sticker-toggle">
                            <i class="fas fa-icons"></i> {{ _('Stickers') }}
                        </button>
                        <div class="toolbar-dropdown" id="sticker-menu">
                            <button type="button" class="dropdown-item" data-emoji="üéâ">üéâ {{ _('Celebrate') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="‚ú®">‚ú® {{ _('Sparkle') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="üî•">üî• {{ _('Fire') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="üí°">üí° {{ _('Idea') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="fa-solid fa-heart">‚ù§ {{ _('Heart') }}</button>
                            <button type="button" class="dropdown-item" data-emoji="fa-solid fa-star">‚≠ê {{ _('Star') }}</button>
                        </div>
                    </div>
                    <button type="button" class="toolbar-btn" id="memory-toggle">
                        <i class="fas fa-archive"></i> {{ _('Memories') }}
                    </button>
                </div>
            </div>
        </div>
        <div class="clipboard-pane memory-pane">
            <h3><i class="fas fa-book-open"></i> {{ _('Memories') }}</h3>
            <div class="memory-list">
                {% if memories %}
                    {% for memory in memories %}
                    <div class="memory-card {{ 'memory-approved' if memory.status == 'approved' else 'memory-pending' }}" data-memory-id="{{ memory.id }}">
                        <div class="memory-header">
                            <span class="memory-date">{{ memory.memory_date }}</span>
                            <span class="memory-status">
                                {% if memory.status == 'approved' %}
                                    <i class="fas fa-check-circle"></i> {{ _('Approved') }}
                                {% else %}
                                    <i class="fas fa-hourglass-half"></i> {{ _('Pending') }}
                                {% endif %}
                            </span>
                        </div>
                        <div class="memory-text">{{ memory.memory_text }}</div>
                        <div class="memory-meta">
                            <span>{{ _('By %(name)s', name=memory.creator_name) }}</span>
                            {% if memory.status == 'approved' and memory.approver_name %}
                                <span>{{ _('Confirmed by %(name)s', name=memory.approver_name) }}</span>
                            {% endif %}
                        </div>
                        {% if memory.status != 'approved' and memory.creator_id != current_user.id %}
                        <button type="button" class="btn btn-sm btn-primary approve-memory-btn" data-memory-id="{{ memory.id }}">
                            <i class="fas fa-check"></i> {{ _('Approve') }}
                        </button>
                        {% endif %}
                    </div>
                    {% endfor %}
                {% else %}
                    <p class="empty-state">{{ _('No memories yet. Add one below!') }}</p>
                {% endif %}
            </div>
            <form class="memory-form" id="memory-form">
                <label for="memory-date">{{ _('Date') }}</label>
                <input type="date" id="memory-date" required>
                <label for="memory-text">{{ _('Memory') }}</label>
                <textarea id="memory-text" maxlength="200" placeholder="{{ _('Add a shared memory...') }}" required></textarea>
                <button type="submit" class="btn btn-primary btn-sm">
                    <i class="fas fa-plus"></i> {{ _('Add Memory') }}
                </button>
            </form>
        </div>
    </div>
    <div class="clipboard-sticker-layer" id="clipboard-sticker-layer"></div>
</div>

<script>
// Diagnostic: Check if socket.io is available
if (typeof io === 'undefined') {
    document.body.insertAdjacentHTML('beforeend', '<div style="position: fixed; bottom: 0; left: 0; right: 0; background: #DC2626; color: white; padding: 10px; text-align: center; z-index: 99999; font-weight: bold;">‚ùå Socket.ioÊú™Âä†ËΩΩ | Socket.io not loaded</div>');
}

let socket = io();
const connectionId = {{ connection.id }};
const myUserId = {{ current_user.id }};
const otherUserId = {{ other_user.id }};
const otherUsername = {{ other_user.username | tojson }};
const memoryEndpoint = {{ url_for('add_memory', connection_id=connection.id) | tojson }};
const approveEndpointTemplate = {{ url_for('approve_memory', connection_id=connection.id, memory_id=0) | tojson }};
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

let roomJoined = false;
let isSocketConnected = false;
let activeMode = 'text';
let moodPrefix = '';
let drawingPlaybackTimer = null;
let drawingPoints = [];
let otherDrawingHistory = [];
let drawingIsComposing = false;
let otherDrawingHasContent = false;
let localDrawingHasContent = false;
let remoteDrawingActive = false;
let isReplaying = false;
let otherLastStroke = 0;

// Show initial connecting status
if (typeof updateSocketStatus === 'function') {
    updateSocketStatus('connecting', '{{ _('Connecting...') }}');
} else {
    // Fallback if function not defined
    const simpleStatus = document.getElementById('simple-socket-status');
    if (simpleStatus) {
        simpleStatus.style.display = 'inline-block';
        simpleStatus.textContent = '‚è≥ {{ _('Connecting...') }}';
    }
}

// Socket connection event handlers
socket.on('connect', function() {
    isSocketConnected = true;
    updateSocketStatus('connected', '{{ _('Connected') }}');
    
    // Track page for online status
    socket.emit('set_page', { page: 'clipboard', connection_id: connectionId });
    
    // Join clipboard room with acknowledgment
    socket.emit('join_clipboard', { connection_id: connectionId }, function(ack) {
        if (ack) {
            roomJoined = true;
        } else {
            showNotification('{{ _('Failed to join clipboard. Please refresh the page.') }}', 'error');
        }
    });
    
    // Get partner status after joining room
    socket.emit('get_user_status', { connection_id: connectionId }, function(status) {
        updatePartnerStatus(status);
    });
});

socket.on('connect_error', function(error) {
    isSocketConnected = false;
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    handleSocketError(error, 'clipboard connect');
});

socket.on('disconnect', function(reason) {
    isSocketConnected = false;
    roomJoined = false;
    updateSocketStatus('disconnected', '{{ _('Disconnected') }}');
    showNotification('{{ _('Connection lost. Changes may not sync until reconnected.') }}', 'warning', 3000);
});

socket.on('reconnect', function(attemptNumber) {
    updateSocketStatus('connected', '{{ _('Reconnected') }}');
    showNotification('{{ _('Reconnected successfully!') }}', 'success', 2000);
});

socket.on('reconnect_attempt', function(attemptNumber) {
    updateSocketStatus('connecting', '{{ _('Reconnecting...') }} (' + attemptNumber + ')');
});

socket.on('reconnect_error', function(error) {
    handleSocketError(error, 'clipboard reconnect');
});

socket.on('reconnect_failed', function() {
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    showNotification('{{ _('Unable to reconnect. Please refresh the page.') }}', 'error', 0);
});

// Track page for online status (initial)
// Moved to connect event handler to ensure socket is connected

// Get partner status (will be called after connection is established)

function updatePartnerStatus(status) {
    const statusEl = document.getElementById('partner-status');
    if (status.online) {
        if (status.page === 'clipboard') {
            statusEl.innerHTML = '<span class="status-online"><i class="fas fa-circle"></i> {{ _('Online') }}</span>';
        } else {
            statusEl.innerHTML = '<span class="status-away"><i class="fas fa-circle"></i> {{ _('Away') }}</span>';
        }
    } else {
        statusEl.innerHTML = '<span class="status-offline"><i class="far fa-circle"></i> {{ _('Offline') }}</span>';
    }
}

socket.on('user_status_changed', function(data) {
    if (data.user_id === otherUserId) {
        updatePartnerStatus({ online: data.online, page: data.page });
    }
});

const myClipboard = document.getElementById('my-clipboard');
const otherClipboard = document.getElementById('other-clipboard');
const myDisplay = document.getElementById('my-display');
const otherDisplay = document.getElementById('other-display');
const myDrawingCanvas = document.getElementById('my-drawing-canvas');
const otherDrawingCanvas = document.getElementById('other-drawing-canvas');
const myDrawingCtx = myDrawingCanvas.getContext('2d');
const otherDrawingCtx = otherDrawingCanvas.getContext('2d');
const stickerLayer = document.getElementById('clipboard-sticker-layer');
const toolbarButtons = document.querySelectorAll('.toolbar-btn[data-mode]');
const moodToggle = document.getElementById('mood-toggle');
const moodMenu = document.getElementById('mood-menu');
const stickerToggle = document.getElementById('sticker-toggle');
const stickerMenu = document.getElementById('sticker-menu');
const memoryToggle = document.getElementById('memory-toggle');
const memoryForm = document.getElementById('memory-form');
const memoryDateInput = document.getElementById('memory-date');
const memoryTextInput = document.getElementById('memory-text');
const approveButtons = document.querySelectorAll('.approve-memory-btn');
const memoryPane = document.querySelector('.memory-pane');
const memoryList = document.querySelector('.memory-list');

function setActiveMode(mode) {
    activeMode = mode;
    toolbarButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    const isDrawing = mode === 'drawing';
    myDisplay.classList.toggle('drawing-active', isDrawing);
    otherDisplay.classList.toggle('drawing-active', isDrawing || remoteDrawingActive);
    if (!isDrawing) {
        stopDrawingPlayback();
        if (localDrawingHasContent) {
            clearMyDrawing();
        }
    } else if (!drawingPoints.length && otherDrawingHistory.length) {
        replayDrawingHistory();
    }
}

function setRemoteDrawingActive(active) {
    remoteDrawingActive = active;
    otherDisplay.classList.toggle('drawing-active', active || activeMode === 'drawing');
}

function toggleDropdown(button, menu) {
    const isOpen = menu.classList.toggle('open');
    button.classList.toggle('active', isOpen);
}

document.addEventListener('click', (event) => {
    if (!moodToggle.contains(event.target) && !moodMenu.contains(event.target)) {
        moodMenu.classList.remove('open');
        moodToggle.classList.remove('active');
    }
    if (!stickerToggle.contains(event.target) && !stickerMenu.contains(event.target)) {
        stickerMenu.classList.remove('open');
        stickerToggle.classList.remove('active');
    }
});

toolbarButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        setActiveMode(btn.dataset.mode);
    });
});

moodToggle.addEventListener('click', () => {
    toggleDropdown(moodToggle, moodMenu);
});

stickerToggle.addEventListener('click', () => {
    toggleDropdown(stickerToggle, stickerMenu);
});

memoryToggle.addEventListener('click', () => {
    memoryPane.classList.toggle('is-open');
    if (memoryPane.classList.contains('is-open')) {
        memoryPane.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
});

if (memoryList && memoryList.querySelector('.memory-card') && memoryPane) {
    memoryPane.classList.add('is-open');
}

moodMenu.querySelectorAll('.dropdown-item').forEach(item => {
    item.addEventListener('click', () => {
        moodPrefix = item.dataset.prefix || '';
        applyMoodPrefix();
        myClipboard.focus();
        moodMenu.classList.remove('open');
        moodToggle.classList.remove('active');
    });
});

stickerMenu.querySelectorAll('.dropdown-item').forEach(item => {
    item.addEventListener('click', () => {
        const emoji = item.dataset.emoji;
        spawnSticker(emoji);
        stickerMenu.classList.remove('open');
        stickerToggle.classList.remove('active');
    });
});

memoryForm.addEventListener('submit', async (event) => {
    event.preventDefault();
    const payload = {
        memory_text: memoryTextInput.value.trim(),
        memory_date: memoryDateInput.value
    };
    if (!payload.memory_text || !payload.memory_date) {
        showNotification('{{ _('Please fill out the memory and date.') }}', 'warning', 2500);
        return;
    }
    try {
        const response = await fetch(memoryEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify(payload)
        });
        const result = await response.json();
        if (!response.ok || !result.success) {
            throw new Error(result.error || '{{ _('Unable to add memory.') }}');
        }
        showNotification('{{ _('Memory submitted for review.') }}', 'success', 2500);
        location.reload();
    } catch (error) {
        showNotification(error.message, 'error');
    }
});

approveButtons.forEach(btn => {
    btn.addEventListener('click', async () => {
        const memoryId = btn.dataset.memoryId;
        if (!memoryId) return;
        try {
            const response = await fetch(approveEndpointTemplate.replace('0/approve', `${memoryId}/approve`), {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                }
            });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.error || '{{ _('Unable to approve memory.') }}');
            }
            showNotification('{{ _('Memory approved!') }}', 'success', 2500);
            location.reload();
        } catch (error) {
            showNotification(error.message, 'error');
        }
    });
});

function spawnSticker(emoji) {
    if (!emoji) return;
    const sticker = document.createElement('div');
    sticker.className = 'sticker-burst';
    if (emoji.startsWith('fa-')) {
        sticker.innerHTML = `<i class="${emoji}"></i>`;
    } else {
        sticker.textContent = emoji;
    }
    const rect = stickerLayer.getBoundingClientRect();
    const startX = Math.random() * rect.width * 0.6 + rect.width * 0.2;
    sticker.style.setProperty('--sticker-start-x', `${startX}px`);
    const shift = (Math.random() * 120) - 60;
    sticker.style.setProperty('--sticker-shift', `${shift}px`);
    stickerLayer.appendChild(sticker);
    sticker.addEventListener('animationend', () => sticker.remove());
}

function prependMoodPrefix(prefix, shouldSend) {
    if (!prefix) return;
    if (!myClipboard.value.startsWith(prefix)) {
        myClipboard.value = prefix + myClipboard.value;
        lastLocalClipboard = myClipboard.value;
        if (shouldSend) {
            sendClipboardUpdate(myClipboard.value);
        }
    }
}

function applyMoodPrefix() {
    const prefix = moodPrefix;
    moodPrefix = '';
    prependMoodPrefix(prefix, true);
}

function clearCanvas(ctx, canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function setupDrawingCanvas(canvas, ctx) {
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    clearCanvas(ctx, canvas);
}

setupDrawingCanvas(myDrawingCanvas, myDrawingCtx);
setupDrawingCanvas(otherDrawingCanvas, otherDrawingCtx);

let isDrawing = false;
let lastX = 0;
let lastY = 0;

function startDraw(e) {
    if (activeMode !== 'drawing') return;
    const rect = myDrawingCanvas.getBoundingClientRect();
    isDrawing = true;
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    emitDrawing({ type: 'stroke_start', x: lastX, y: lastY });
}

function drawStroke(x, y) {
    myDrawingCtx.lineWidth = 4;
    myDrawingCtx.strokeStyle = '#1f2937';
    myDrawingCtx.lineTo(x, y);
    myDrawingCtx.stroke();
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(x, y);
    localDrawingHasContent = true;
    emitDrawing({ type: 'draw', x, y });
}

function moveDraw(e) {
    if (!isDrawing || activeMode !== 'drawing') return;
    const rect = myDrawingCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    drawStroke(x, y);
    lastX = x;
    lastY = y;
}

function endDraw() {
    if (!isDrawing) return;
    isDrawing = false;
    myDrawingCtx.beginPath();
    emitDrawing({ type: 'stroke_end' });
}

function emitDrawing(drawing) {
    if (!roomJoined || !isSocketConnected) return;
    socket.emit('clipboard_drawing', {
        connection_id: connectionId,
        drawing
    });
}

function clearMyDrawing() {
    clearCanvas(myDrawingCtx, myDrawingCanvas);
    emitDrawing({ type: 'clear' });
    localDrawingHasContent = false;
    setRemoteDrawingActive(false);
}

myDrawingCanvas.addEventListener('mousedown', startDraw);
myDrawingCanvas.addEventListener('mousemove', moveDraw);
myDrawingCanvas.addEventListener('mouseup', endDraw);
myDrawingCanvas.addEventListener('mouseout', endDraw);

myDrawingCanvas.addEventListener('touchstart', (event) => {
    event.preventDefault();
    if (activeMode !== 'drawing') return;
    const touch = event.touches[0];
    const rect = myDrawingCanvas.getBoundingClientRect();
    isDrawing = true;
    lastX = touch.clientX - rect.left;
    lastY = touch.clientY - rect.top;
    myDrawingCtx.beginPath();
    myDrawingCtx.moveTo(lastX, lastY);
    emitDrawing({ type: 'stroke_start', x: lastX, y: lastY });
}, { passive: false });

myDrawingCanvas.addEventListener('touchmove', (event) => {
    event.preventDefault();
    if (!isDrawing || activeMode !== 'drawing') return;
    const touch = event.touches[0];
    const rect = myDrawingCanvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    drawStroke(x, y);
}, { passive: false });

myDrawingCanvas.addEventListener('touchend', (event) => {
    event.preventDefault();
    endDraw();
}, { passive: false });

function queueDrawingPoint(drawing) {
    if (drawing.type === 'clear') {
        otherDrawingHistory = [];
        drawingPoints = [];
        otherDrawingHasContent = false;
        clearCanvas(otherDrawingCtx, otherDrawingCanvas);
        setRemoteDrawingActive(false);
        return;
    } else {
        otherDrawingHistory.push(drawing);
        otherDrawingHasContent = true;
        drawingPoints.push(drawing);
    }
    otherLastStroke = Date.now();
    if (drawing.type === 'stroke_start' || drawing.type === 'draw') {
        setRemoteDrawingActive(true);
    }
}

function stopDrawingPlayback() {
    if (drawingPlaybackTimer) {
        clearInterval(drawingPlaybackTimer);
        drawingPlaybackTimer = null;
    }
    isReplaying = false;
}

function startDrawingPlayback() {
    if (drawingPlaybackTimer) return;
    isReplaying = true;
    drawingPlaybackTimer = setInterval(() => {
        if (drawingPoints.length === 0) {
            stopDrawingPlayback();
            return;
        }
        const drawing = drawingPoints.shift();
        renderDrawing(otherDrawingCtx, otherDrawingCanvas, drawing);
    }, 40);
}

function renderDrawing(ctx, canvas, drawing) {
    if (!drawing) return;
    if (drawing.type === 'clear') {
        clearCanvas(ctx, canvas);
        if (ctx === otherDrawingCtx) {
            otherDrawingHistory = [];
            otherDrawingHasContent = false;
        }
        return;
    }
    if (drawing.type === 'stroke_end' || drawing.type === 'stroke_start') {
        ctx.beginPath();
        if (drawing.type === 'stroke_start') {
            ctx.moveTo(drawing.x, drawing.y);
        }
        return;
    }
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#1f2937';
    ctx.lineTo(drawing.x, drawing.y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(drawing.x, drawing.y);
    if (ctx === otherDrawingCtx) {
        otherDrawingHasContent = true;
    }
}

function replayDrawingHistory() {
    if (!otherDrawingHistory.length) {
        return;
    }
    drawingPoints = otherDrawingHistory.slice();
    clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    startDrawingPlayback();
}

// Load existing content
{% if clipboard_data %}
    {% if current_user.id in clipboard_data %}
    document.getElementById('my-clipboard').value = {{ clipboard_data[current_user.id].content|tojson }};
    {% endif %}
    {% if other_user.id in clipboard_data %}
    document.getElementById('other-clipboard').value = {{ clipboard_data[other_user.id].content|tojson }};
    {% endif %}
{% endif %}
let lastLocalClipboard = myClipboard.value;

function shouldUpdateLocalClipboard(content) {
    return document.activeElement !== myClipboard && content !== lastLocalClipboard;
}

// Send updates with shorter delay for faster sync
let timeout;
let isComposing = false; // Track IME composition state

function sendClipboardUpdate(content) {
    if (!isSocketConnected) {
        showNotification('{{ _('Not connected. Changes will sync when connection is restored.') }}', 'warning', 3000);
        return;
    }
    if (roomJoined) {
        socket.emit('clipboard_update', {
            connection_id: connectionId,
            content: content
        });
    }
}

myClipboard.addEventListener('compositionstart', function(e) {
    isComposing = true;
    drawingIsComposing = true;
});

myClipboard.addEventListener('input', function(e) {
    // Skip input event during IME composition to avoid conflicts
    if (isComposing) {
        return;
    }
    
    clearTimeout(timeout);
    if (!drawingIsComposing && moodPrefix) {
        const prefix = moodPrefix;
        const hasPrefix = e.target.value.startsWith(prefix);
        moodPrefix = '';
        prependMoodPrefix(prefix, false);
        if (!hasPrefix) {
            const selectionStart = e.target.selectionStart;
            const selectionEnd = e.target.selectionEnd;
            const offset = prefix.length;
            e.target.setSelectionRange(selectionStart + offset, selectionEnd + offset);
        }
    }
    setRemoteDrawingActive(false);
    clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    lastLocalClipboard = e.target.value;
    timeout = setTimeout(() => {
        sendClipboardUpdate(e.target.value);
    }, 200); // Reduced from 500ms to 200ms for faster sync
});
 
// Add support for composition events (pinyin/IME input)
myClipboard.addEventListener('compositionupdate', function(e) {
    // Sync even during composition (pinyin typing)
    clearTimeout(timeout);
    lastLocalClipboard = e.target.value;
    timeout = setTimeout(() => {
        sendClipboardUpdate(myClipboard.value); // Use current value to avoid race conditions
    }, 150); // Even faster for composition to show real-time pinyin
});

myClipboard.addEventListener('compositionend', function(e) {
    isComposing = false;
    drawingIsComposing = false;
    // Final sync when composition completes
    clearTimeout(timeout);
    lastLocalClipboard = e.target.value;
    sendClipboardUpdate(e.target.value);
});

myClipboard.addEventListener('focus', () => {
    setActiveMode('text');
});

// Receive updates
socket.on('clipboard_sync', function(data) {
    if (data.user_id === myUserId) {
        if (shouldUpdateLocalClipboard(data.content)) {
            myClipboard.value = data.content;
        }
        return;
    }
    if (data.content !== otherClipboard.value) {
        otherClipboard.value = data.content;
    }
    if (data.content.trim()) {
        setRemoteDrawingActive(false);
        clearCanvas(otherDrawingCtx, otherDrawingCanvas);
    }
});

socket.on('clipboard_drawing_update', function(data) {
    if (data.user_id === myUserId) {
        renderDrawing(myDrawingCtx, myDrawingCanvas, data.drawing);
        if (data.drawing.type === 'clear') {
            clearCanvas(myDrawingCtx, myDrawingCanvas);
        }
        return;
    }
    queueDrawingPoint(data.drawing);
    startDrawingPlayback();
});

setActiveMode('text');
setInterval(() => {
    if (!remoteDrawingActive) {
        return;
    }
    const idleTooLong = Date.now() - otherLastStroke > 2000;
    const hasHistory = otherDrawingHistory.length > 0;
    const noPending = drawingPoints.length === 0;
    if (noPending && hasHistory && otherDrawingHasContent && !isReplaying && idleTooLong) {
        replayDrawingHistory();
    }
    if (Date.now() - otherLastStroke > 5000) {
        setRemoteDrawingActive(false);
    }
}, 2000);
</script>
{% endblock %}
