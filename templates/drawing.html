{% extends "base.html" %}

{% block title %}{{ _('Drawing Game') }} - {{ _('Social Connect') }}{% endblock %}

{% block content %}
<div class="container">
    <div class="page-header">
        <h1><i class="fas fa-palette"></i> {{ _('Drawing Game with %(username)s', username=other_user.username) }}</h1>
        <div>
            <span id="partner-status" class="partner-status"></span>
            <a href="{{ url_for('dashboard') }}" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> {{ _('Back') }}</a>
        </div>
    </div>
    
    <div class="game-container">
        <div class="game-info" id="game-info">
            <div class="score-board" id="score-board" style="display: none;">
                <span id="round-info"></span>
                <span id="score-info"></span>
            </div>
        </div>
        
        <div class="game-status" id="game-status">
            <p>{{ _('Connecting...') }}</p>
        </div>
        
        <div id="waiting-screen" class="waiting-screen" style="display: none;">
            <div class="waiting-content">
                <i class="fas fa-hourglass-half fa-spin fa-3x"></i>
                <h3>{{ _('Waiting for partner to join...') }}</h3>
                <p>{{ _('The game will start automatically when your partner enters the drawing page.') }}</p>
            </div>
        </div>
        
        <div id="start-screen" class="start-screen" style="display: none;">
            <button onclick="showDrawingSetup()" class="btn btn-primary btn-lg"><i class="fas fa-play"></i> {{ _('Start New Round') }}</button>
        </div>
        
        <div id="drawing-setup" class="drawing-setup" style="display: none;">
            <h3>{{ _('Enter the word to draw:') }}</h3>
            <input type="text" id="answer-input" placeholder="{{ _('Enter a word...') }}" maxlength="50">
            <div class="setup-buttons">
                <button onclick="startDrawing()" class="btn btn-primary"><i class="fas fa-check"></i> {{ _('Start Drawing') }}</button>
                <button onclick="cancelSetup()" class="btn btn-secondary"><i class="fas fa-times"></i> {{ _('Cancel') }}</button>
            </div>
        </div>
        
        <div id="drawing-area" class="drawing-area" style="display: none;">
            <canvas id="drawing-canvas" width="600" height="400"></canvas>
            <div class="drawing-controls">
                <button onclick="clearCanvas()" class="btn btn-warning"><i class="fas fa-eraser"></i> {{ _('Clear') }}</button>
                <label for="color-picker">{{ _('Color:') }}</label>
                <input type="color" id="color-picker" value="#000000">
                <label for="brush-size">{{ _('Size:') }}</label>
                <input type="range" id="brush-size" min="1" max="20" value="5">
                <span id="brush-size-value">5</span>
            </div>
        </div>
        
        <div id="guessing-area" class="guessing-area" style="display: none;">
            <canvas id="guess-canvas" width="600" height="400"></canvas>
            <div class="guess-controls">
                <div id="guesses-left" class="guesses-left"></div>
                <input type="text" id="guess-input" placeholder="{{ _('Enter your guess...') }}" maxlength="50">
                <button onclick="submitGuess()" class="btn btn-primary"><i class="fas fa-check"></i> {{ _('Guess') }}</button>
            </div>
        </div>
        
        <div id="session-complete" class="session-complete" style="display: none;">
            <h2>{{ _('Game Complete!') }}</h2>
            <div id="final-scores"></div>
            <button onclick="startNewSession()" class="btn btn-primary btn-lg"><i class="fas fa-redo"></i> {{ _('Play Again') }}</button>
        </div>
    </div>
</div>

<script>
// Diagnostic: Check if socket.io is available
if (typeof io === 'undefined') {
    document.body.insertAdjacentHTML('beforeend', '<div style="position: fixed; bottom: 0; left: 0; right: 0; background: #DC2626; color: white; padding: 10px; text-align: center; z-index: 99999; font-weight: bold;">❌ Socket.io未加载 | Socket.io not loaded</div>');
}

const socket = io();
const connectionId = {{ connection.id }};
const myUserId = {{ current_user.id }};
const otherUserId = {{ other_user.id }};
const otherUsername = {{ other_user.username | tojson }};

// Configuration constants
const SOCKET_ACK_TIMEOUT = 10000; // 10 seconds

let isDrawing = false;
let isDrawer = false;
let canvas, ctx, guessCanvas, guessCtx;
let currentGuessesLeft = 3;
let roomJoined = false;
let currentSession = null;
let isSocketConnected = false;

// Show initial connecting status
if (typeof updateSocketStatus === 'function') {
    updateSocketStatus('connecting', '{{ _('Connecting...') }}');
} else {
    // Fallback if function not defined
    const simpleStatus = document.getElementById('simple-socket-status');
    if (simpleStatus) {
        simpleStatus.style.display = 'inline-block';
        simpleStatus.textContent = '⏳ {{ _('Connecting...') }}';
    }
}

// Socket connection event handlers
socket.on('connect', function() {
    isSocketConnected = true;
    updateSocketStatus('connected', '{{ _('Connected') }}');
    
    // Track page for online status
    socket.emit('set_page', { page: 'drawing', connection_id: connectionId });
    
    // Join drawing room
    joinDrawingRoom();
    
    // Get partner status after joining
    socket.emit('get_user_status', { connection_id: connectionId }, function(status) {
        updatePartnerStatus(status);
    });
});

socket.on('connect_error', function(error) {
    isSocketConnected = false;
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    handleSocketError(error, 'drawing connect');
    document.getElementById('game-status').innerHTML = '<p class="error">{{ _('Connection error. Please check your internet and refresh.') }}</p>';
});

socket.on('disconnect', function(reason) {
    isSocketConnected = false;
    roomJoined = false;
    updateSocketStatus('disconnected', '{{ _('Disconnected') }}');
    showNotification('{{ _('Connection lost. Attempting to reconnect...') }}', 'warning', 3000);
    document.getElementById('game-status').innerHTML = '<p class="error">{{ _('Disconnected. Reconnecting...') }}</p>';
});

socket.on('reconnect', function(attemptNumber) {
    updateSocketStatus('connected', '{{ _('Reconnected') }}');
    showNotification('{{ _('Reconnected successfully!') }}', 'success', 2000);
});

socket.on('reconnect_attempt', function(attemptNumber) {
    updateSocketStatus('connecting', '{{ _('Reconnecting...') }} (' + attemptNumber + ')');
});

socket.on('reconnect_error', function(error) {
    handleSocketError(error, 'drawing reconnect');
});

socket.on('reconnect_failed', function() {
    updateSocketStatus('disconnected', '{{ _('Connection failed') }}');
    showNotification('{{ _('Unable to reconnect. Please refresh the page.') }}', 'error', 0);
});

// Track page for online status (initial)
// Moved to connect event handler to ensure socket is connected

// Join drawing room with acknowledgment
function joinDrawingRoom() {
    if (!isSocketConnected) {
        document.getElementById('game-status').innerHTML = '<p class="error">{{ _('Not connected. Please wait...') }}</p>';
        return;
    }
    
    socket.emit('join_drawing', { connection_id: connectionId }, function(response) {
        if (response && response.success) {
            roomJoined = true;
            currentSession = response.session;
            handleSessionState(response.session);
        } else {
            const errorMsg = response && response.error ? response.error : '{{ _('Failed to join game. Please refresh the page.') }}';
            document.getElementById('game-status').innerHTML = '<p class="error">' + errorMsg + '</p>';
            showNotification(errorMsg, 'error');
        }
    });
}

// joinDrawingRoom() will be called on connect event
// Removed duplicate call here to avoid errors on page load

// Get partner status (will be called after connection is established)

function updatePartnerStatus(status) {
    const statusEl = document.getElementById('partner-status');
    if (status.online) {
        if (status.page === 'drawing') {
            statusEl.innerHTML = '<span class="status-online"><i class="fas fa-circle"></i> ' + otherUsername + ' {{ _("is in Drawing") }}</span>';
        } else {
            statusEl.innerHTML = '<span class="status-away"><i class="fas fa-circle"></i> ' + otherUsername + ' {{ _("is online") }}</span>';
        }
    } else {
        statusEl.innerHTML = '<span class="status-offline"><i class="far fa-circle"></i> ' + otherUsername + ' {{ _("is offline") }}</span>';
    }
}

socket.on('user_status_changed', function(data) {
    if (data.user_id === otherUserId) {
        updatePartnerStatus({ online: data.online, page: data.page });
    }
});

function handleSessionState(session) {
    if (!session) {
        showStartScreen();
        return;
    }
    
    currentSession = session;
    updateScoreBoard();
    
    if (session.waiting) {
        // Waiting for partner
        if (session.is_creator) {
            showWaitingScreen();
        } else {
            // We just joined, show start screen
            showStartScreen();
        }
    } else {
        // Session is active
        // Check if there's an active game
        {% if game %}
            {% if game.drawer_id == current_user.id %}
                isDrawer = true;
                showDrawingArea();
            {% else %}
                isDrawer = false;
                currentGuessesLeft = {{ game.guesses_left }};
                showGuessingArea(currentGuessesLeft);
            {% endif %}
        {% else %}
            showStartScreen();
        {% endif %}
    }
}

function updateScoreBoard() {
    if (!currentSession) return;
    
    const scoreBoard = document.getElementById('score-board');
    const roundInfo = document.getElementById('round-info');
    const scoreInfo = document.getElementById('score-info');
    
    scoreBoard.style.display = 'flex';
    roundInfo.textContent = `{{ _('Round:') }} ${currentSession.current_round} / ${currentSession.total_rounds}`;
    scoreInfo.textContent = `{{ _('Score:') }} {{ current_user.username }}: ${currentSession.user1_score || 0} | ${otherUsername}: ${currentSession.user2_score || 0}`;
}

function showWaitingScreen() {
    hideAllScreens();
    document.getElementById('waiting-screen').style.display = 'block';
    document.getElementById('game-status').innerHTML = '<p>{{ _('You created a new game session. Waiting for partner to join...') }}</p>';
}

function showStartScreen() {
    hideAllScreens();
    document.getElementById('start-screen').style.display = 'block';
    document.getElementById('game-status').innerHTML = '<p>{{ _('Ready to play! Click "Start New Round" to begin.') }}</p>';
}

function hideAllScreens() {
    document.getElementById('waiting-screen').style.display = 'none';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('drawing-setup').style.display = 'none';
    document.getElementById('drawing-area').style.display = 'none';
    document.getElementById('guessing-area').style.display = 'none';
    document.getElementById('session-complete').style.display = 'none';
}

function showDrawingSetup() {
    hideAllScreens();
    document.getElementById('drawing-setup').style.display = 'block';
    document.getElementById('answer-input').focus();
}

function cancelSetup() {
    showStartScreen();
}

function startDrawing() {
    const answer = document.getElementById('answer-input').value.trim();
    if (!answer) {
        showNotification('{{ _('Please enter a word!') }}', 'warning');
        return;
    }
    
    if (!isSocketConnected) {
        showNotification('{{ _('Not connected. Please wait for connection to be established.') }}', 'error');
        return;
    }
    
    if (!roomJoined) {
        showNotification('{{ _('Connecting... Please try again in a moment.') }}', 'warning');
        return;
    }
    
    // Add timeout for acknowledgment
    let timeoutId = setTimeout(() => {
        showNotification('{{ _('Request timeout. Please try again.') }}', 'error');
        // Could add UI reset here if needed in future
    }, SOCKET_ACK_TIMEOUT);
    
    socket.emit('drawing_start', {
        connection_id: connectionId,
        answer: answer
    }, function(response) {
        clearTimeout(timeoutId);
        
        if (!response || !response.success) {
            const errorMsg = response && response.error ? response.error : '{{ _('Unable to start drawing. Please try again.') }}';
            showNotification(errorMsg, 'error');
            return;
        }
        document.getElementById('answer-input').value = '';
        isDrawer = true;
        showDrawingArea();
    });
}

function showDrawingArea() {
    hideAllScreens();
    document.getElementById('drawing-area').style.display = 'block';
    document.getElementById('game-status').innerHTML = '<p><i class="fas fa-pencil-alt"></i> {{ _('You are drawing! Draw your word and let the other player guess.') }}</p>';
    
    setupCanvas('drawing-canvas');
}

function showGuessingArea(guessesLeft) {
    hideAllScreens();
    document.getElementById('guessing-area').style.display = 'block';
    updateGuessesLeft(guessesLeft || 3);
    document.getElementById('game-status').innerHTML = '<p><i class="fas fa-eye"></i> {{ _('The other player is drawing. Watch and guess!') }}</p>';
    
    guessCanvas = document.getElementById('guess-canvas');
    guessCtx = guessCanvas.getContext('2d');
    guessCtx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
}

function updateGuessesLeft(count) {
    currentGuessesLeft = count;
    document.getElementById('guesses-left').innerHTML = `<i class="fas fa-lightbulb"></i> {{ _('Guesses left:') }} ${count}`;
}

function setupCanvas(canvasId) {
    canvas = document.getElementById(canvasId);
    ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Remove existing listeners first
    canvas.removeEventListener('mousedown', startDrawingEvent);
    canvas.removeEventListener('mousemove', draw);
    canvas.removeEventListener('mouseup', stopDrawingEvent);
    canvas.removeEventListener('mouseout', stopDrawingEvent);
    canvas.removeEventListener('touchstart', handleTouchStart);
    canvas.removeEventListener('touchmove', handleTouchMove);
    canvas.removeEventListener('touchend', handleTouchEnd);
    
    canvas.addEventListener('mousedown', startDrawingEvent);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawingEvent);
    canvas.addEventListener('mouseout', stopDrawingEvent);
    
    // Touch events for mobile/tablet
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
}

// Brush size display
const brushSizeInput = document.getElementById('brush-size');
if (brushSizeInput) {
    brushSizeInput.addEventListener('input', function() {
        document.getElementById('brush-size-value').textContent = this.value;
    });
}

let lastX = 0, lastY = 0;

function startDrawingEvent(e) {
    if (!isDrawer) return;
    isDrawing = true;
    const rect = canvas.getBoundingClientRect();
    lastX = e.clientX - rect.left;
    lastY = e.clientY - rect.top;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
}

function draw(e) {
    if (!isDrawing || !isDrawer) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const color = document.getElementById('color-picker').value;
    const size = document.getElementById('brush-size').value;
    
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = color;
    
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
    
    // Send drawing data
    socket.emit('drawing_data', {
        connection_id: connectionId,
        drawing: { x, y, color, size, type: 'draw' }
    });
    
    lastX = x;
    lastY = y;
}

function stopDrawingEvent() {
    if (isDrawing) {
        isDrawing = false;
        ctx.beginPath();
        // Send a stroke-end event
        socket.emit('drawing_data', {
            connection_id: connectionId,
            drawing: { type: 'stroke_end' }
        });
    }
}

function handleTouchStart(e) {
    e.preventDefault();
    if (!isDrawer) return;
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    lastX = touch.clientX - rect.left;
    lastY = touch.clientY - rect.top;
    
    isDrawing = true;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
}

function handleTouchMove(e) {
    e.preventDefault();
    if (!isDrawing || !isDrawer) return;
    
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    const color = document.getElementById('color-picker').value;
    const size = document.getElementById('brush-size').value;
    
    ctx.lineWidth = size;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = color;
    
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x, y);
    
    // Send drawing data
    socket.emit('drawing_data', {
        connection_id: connectionId,
        drawing: { x, y, color, size, type: 'draw' }
    });
    
    lastX = x;
    lastY = y;
}

function handleTouchEnd(e) {
    e.preventDefault();
    stopDrawingEvent();
}

function clearCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    socket.emit('drawing_data', {
        connection_id: connectionId,
        drawing: { type: 'clear' }
    });
}

function submitGuess() {
    const guessInput = document.getElementById('guess-input');
    const guess = guessInput.value.trim();
    if (!guess) return;
    
    if (!isSocketConnected) {
        showNotification('{{ _('Not connected. Please wait for connection to be established.') }}', 'error');
        return;
    }
    
    if (!roomJoined) {
        showNotification('{{ _('Connecting... Please try again in a moment.') }}', 'warning');
        return;
    }
    
    socket.emit('drawing_guess', {
        connection_id: connectionId,
        guess: guess
    });
    
    guessInput.value = '';
}

// Allow enter key to submit guess
const guessInputEl = document.getElementById('guess-input');
if (guessInputEl) {
    guessInputEl.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            submitGuess();
        }
    });
}

// Allow enter key to start drawing
const answerInputEl = document.getElementById('answer-input');
if (answerInputEl) {
    answerInputEl.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            startDrawing();
        }
    });
}

function startNewSession() {
    // Reload to create a new session
    location.reload();
}

// Socket events
socket.on('session_joined', function(data) {
    // Partner joined our session
    currentSession = {
        id: data.session_id,
        waiting: false,
        current_round: data.current_round,
        total_rounds: data.total_rounds
    };
    updateScoreBoard();
    showStartScreen();
    document.getElementById('game-status').innerHTML = '<p><i class="fas fa-check-circle"></i> ' + otherUsername + ' {{ _('joined! Start a round.') }}</p>';
});

socket.on('game_started', function(data) {
    if (currentSession) {
        currentSession.current_round = data.round;
    }
    updateScoreBoard();
    
    if (data.drawer_id === myUserId) {
        isDrawer = true;
        showDrawingArea();
        document.getElementById('game-status').innerHTML = '<p><i class="fas fa-pencil-alt"></i> {{ _('Round') }} ' + data.round + ' - {{ _('You are drawing!') }}</p>';
    } else {
        isDrawer = false;
        currentGuessesLeft = data.guesses_left || 3;
        showGuessingArea(currentGuessesLeft);
        document.getElementById('game-status').innerHTML = '<p><i class="fas fa-eye"></i> {{ _('Round') }} ' + data.round + ' - ' + data.drawer_name + ' {{ _('is drawing. Start guessing!') }}</p>';
    }
});

socket.on('drawing_update', function(data) {
    if (!isDrawer && guessCtx) {
        const d = data.drawing;
        if (d.type === 'clear') {
            guessCtx.clearRect(0, 0, guessCanvas.width, guessCanvas.height);
        } else if (d.type === 'stroke_end') {
            guessCtx.beginPath();
        } else {
            guessCtx.lineWidth = d.size;
            guessCtx.lineCap = 'round';
            guessCtx.lineJoin = 'round';
            guessCtx.strokeStyle = d.color;
            guessCtx.lineTo(d.x, d.y);
            guessCtx.stroke();
            guessCtx.beginPath();
            guessCtx.moveTo(d.x, d.y);
        }
    }
});

socket.on('guess_result', function(data) {
    // Update session scores
    if (currentSession) {
        currentSession.user1_score = data.user1_score;
        currentSession.user2_score = data.user2_score;
        currentSession.current_round = data.current_round;
    }
    updateScoreBoard();
    
    if (data.session_complete) {
        // Show session complete screen
        showSessionComplete(data);
    } else if (data.correct) {
        showNotification('{{ _('Correct! The answer was:') }} ' + data.answer, 'success', 4000);
        showStartScreen();
        document.getElementById('game-status').innerHTML = '<p><i class="fas fa-check-circle"></i> {{ _('Round complete! Start the next round.') }}</p>';
    } else if (data.game_over) {
        showNotification('{{ _('Game over! The answer was:') }} ' + data.answer, 'warning', 4000);
        showStartScreen();
        document.getElementById('game-status').innerHTML = '<p><i class="fas fa-times-circle"></i> {{ _('Round complete! Start the next round.') }}</p>';
    } else {
        // Wrong guess
        currentGuessesLeft--;
        updateGuessesLeft(currentGuessesLeft);
    }
});

socket.on('session_ended', function(data) {
    showNotification('{{ _('Session ended:') }} ' + data.reason, 'warning', 8000);
    // Give user time to see the message before reloading
    setTimeout(() => {
        if (confirm('{{ _('Session ended. Click OK to reload the page.') }}')) {
            location.reload();
        }
    }, 2000);
});

function showSessionComplete(data) {
    hideAllScreens();
    document.getElementById('session-complete').style.display = 'block';
    
    let winner = '';
    if (data.user1_score > data.user2_score) {
        winner = '{{ current_user.username }} {{ _('wins!') }}';
    } else if (data.user2_score > data.user1_score) {
        winner = otherUsername + ' {{ _('wins!') }}';
    } else {
        winner = '{{ _("It\'s a tie!") }}';
    }
    
    document.getElementById('final-scores').innerHTML = 
        '<h3>' + winner + '</h3>' +
        '<p>{{ current_user.username }}: ' + data.user1_score + ' | ' + otherUsername + ': ' + data.user2_score + '</p>';
    
    document.getElementById('game-status').innerHTML = '<p><i class="fas fa-trophy"></i> {{ _('Game Complete!') }}</p>';
}

// Notify when leaving the page
window.addEventListener('beforeunload', function() {
    if (currentSession && currentSession.waiting && currentSession.is_creator) {
        socket.emit('end_drawing_session', { connection_id: connectionId });
    }
});
</script>
{% endblock %}
